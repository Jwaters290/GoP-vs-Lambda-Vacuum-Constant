"""
Enhanced single-void aperture photometry on Planck CMB maps (HEALPix).

Adds to the minimal version:
- Multi-map support (pass multiple component-separated maps)
- Bootstrap uncertainty on the compensated aperture statistic
- Matched-latitude random-center null distribution
- JSON output (stdout + optional --out_json)

Statistic:
  ΔT = <T>_core - <T>_rim
where:
  core = disc of radius core_frac * θ_R
  rim  = annulus between rim_in_frac * θ_R and rim_out_frac * θ_R

Notes
- This is still a *single-void* check; statistical power typically comes from stacking.
- The null distribution is generated by sampling random centers on the sky subject to:
  (i) center pixel unmasked; (ii) |b| >= bmin_deg (configurable).

Typical usage:
python measurements/bootes_aperture_photometry_plus.py \
  --cmb_map data/COM_CMB_IQU-smica_2048_R3.00_full.fits \
  --mask data/COM_Mask_CMB-common-Mask-Int_2048_R3.00_full.fits \
  --mask_threshold 0.85 \
  --ra_deg 222.5 --dec_deg 46.0 \
  --theta_R_deg 14.0 \
  --bootstrap 2000 --null_rand 2000 --bmin_deg 50 --seed 0 \
  --out_json runs/measurements_bootes_smica_theta14.json
"""

import argparse
import json
import numpy as np
import healpy as hp
from astropy.coordinates import SkyCoord
import astropy.units as u


# -----------------------------
# I/O helpers
# -----------------------------
def load_healpix_map(map_path: str, field: int = 0) -> np.ndarray:
    m = hp.read_map(map_path, field=field, verbose=False)
    return np.array(m, dtype=np.float64)


def to_uK(m: np.ndarray, map_in_uK: bool) -> np.ndarray:
    return m if map_in_uK else (m * 1e6)


def load_keep_mask(mask_path: str, field: int = 0, threshold: float = 0.8) -> np.ndarray:
    mk = hp.read_map(mask_path, field=field, verbose=False)
    mk = np.array(mk, dtype=np.float64)
    return mk >= threshold


# -----------------------------
# Coordinate helpers
# -----------------------------
def radec_to_galactic(ra_deg: float, dec_deg: float) -> tuple[float, float]:
    c = SkyCoord(ra=ra_deg * u.deg, dec=dec_deg * u.deg, frame="icrs")
    g = c.galactic
    return float(g.l.deg), float(g.b.deg)


# -----------------------------
# Region masks
# -----------------------------
def disc_mask(nside: int, vec_center: np.ndarray, radius_rad: float) -> np.ndarray:
    ipix = hp.query_disc(nside, vec_center, radius_rad, inclusive=False)
    m = np.zeros(hp.nside2npix(nside), dtype=bool)
    m[ipix] = True
    return m


def annulus_mask(nside: int, vec_center: np.ndarray, r_in_rad: float, r_out_rad: float) -> np.ndarray:
    outer = disc_mask(nside, vec_center, r_out_rad)
    inner = disc_mask(nside, vec_center, r_in_rad)
    return outer & (~inner)


def build_core_rim_masks(
    nside: int,
    lon_deg: float,
    lat_deg: float,
    theta_R_deg: float,
    core_frac: float,
    rim_in_frac: float,
    rim_out_frac: float,
) -> tuple[np.ndarray, np.ndarray]:
    # healpy angles: theta=colatitude, phi=longitude
    phi = np.deg2rad(lon_deg)
    theta = np.deg2rad(90.0 - lat_deg)
    vec = hp.ang2vec(theta, phi)

    theta_R = np.deg2rad(theta_R_deg)
    core_r = core_frac * theta_R
    rim_in = rim_in_frac * theta_R
    rim_out = rim_out_frac * theta_R

    core = disc_mask(nside, vec, core_r)
    rim = annulus_mask(nside, vec, rim_in, rim_out)
    return core, rim


# -----------------------------
# Core statistic
# -----------------------------
def deltaT_from_masks(
    cmb_uK: np.ndarray,
    keep: np.ndarray,
    core: np.ndarray,
    rim: np.ndarray,
    min_pix: int = 50,
) -> tuple[float, float, float, int, int]:
    good = np.isfinite(cmb_uK)
    core_sel = core & keep & good
    rim_sel = rim & keep & good

    ncore = int(core_sel.sum())
    nrim = int(rim_sel.sum())

    if ncore < min_pix or nrim < min_pix:
        raise RuntimeError(
            f"Too few pixels after masking (core={ncore}, rim={nrim}, min={min_pix}). "
            "Try adjusting θ_R, mask threshold, or mask choice."
        )

    Tcore = float(np.mean(cmb_uK[core_sel]))
    Trim = float(np.mean(cmb_uK[rim_sel]))
    dT = Tcore - Trim
    return dT, Tcore, Trim, ncore, nrim


# -----------------------------
# Bootstrap uncertainty
# -----------------------------
def bootstrap_deltaT(
    cmb_uK: np.ndarray,
    keep: np.ndarray,
    core: np.ndarray,
    rim: np.ndarray,
    n_boot: int = 1000,
    seed: int = 0,
    min_pix: int = 50,
) -> dict:
    rng = np.random.default_rng(seed)
    good = np.isfinite(cmb_uK)

    core_pix = np.where(core & keep & good)[0]
    rim_pix = np.where(rim & keep & good)[0]

    if len(core_pix) < min_pix or len(rim_pix) < min_pix:
        raise RuntimeError(
            f"Too few pixels for bootstrap (core={len(core_pix)}, rim={len(rim_pix)})."
        )

    vals = np.empty(n_boot, dtype=np.float64)
    for i in range(n_boot):
        sc = rng.choice(core_pix, size=len(core_pix), replace=True)
        sr = rng.choice(rim_pix, size=len(rim_pix), replace=True)
        vals[i] = np.mean(cmb_uK[sc]) - np.mean(cmb_uK[sr])

    return {
        "n": int(n_boot),
        "mean_uK": float(np.mean(vals)),
        "std_uK": float(np.std(vals, ddof=1)),
        "p16_uK": float(np.percentile(vals, 16)),
        "p50_uK": float(np.percentile(vals, 50)),
        "p84_uK": float(np.percentile(vals, 84)),
    }


# -----------------------------
# Null distribution via random centers
# -----------------------------
def sample_random_centers(
    n: int,
    keep: np.ndarray,
    bmin_deg: float,
    seed: int = 0,
    max_tries_factor: int = 500,
) -> list[tuple[float, float]]:
    """
    Sample random Galactic centers (l,b) uniformly on the sphere,
    with |b| >= bmin_deg and center pixel unmasked.
    """
    rng = np.random.default_rng(seed)
    nside = hp.get_nside(keep.astype(np.float64))
    out: list[tuple[float, float]] = []

    max_tries = n * max_tries_factor
    tries = 0

    while len(out) < n and tries < max_tries:
        tries += 1
        l = rng.uniform(0.0, 360.0)
        # uniform in sin(b)
        sinb = rng.uniform(-1.0, 1.0)
        b = np.rad2deg(np.arcsin(sinb))

        if abs(b) < bmin_deg:
            continue

        theta = np.deg2rad(90.0 - b)
        phi = np.deg2rad(l)
        ipix = hp.ang2pix(nside, theta, phi)

        if keep[ipix]:
            out.append((float(l), float(b)))

    if len(out) < n:
        raise RuntimeError(
            f"Failed to sample enough random centers (got {len(out)} of {n}). "
            "Lower bmin_deg or relax mask_threshold."
        )

    return out


def null_distribution(
    cmb_uK: np.ndarray,
    keep: np.ndarray,
    theta_R_deg: float,
    core_frac: float,
    rim_in_frac: float,
    rim_out_frac: float,
    n_rand: int = 1000,
    bmin_deg: float = 50.0,
    seed: int = 0,
    min_pix: int = 50,
) -> dict:
    nside = hp.get_nside(cmb_uK)
    centers = sample_random_centers(n_rand, keep, bmin_deg=bmin_deg, seed=seed)

    vals = np.empty(n_rand, dtype=np.float64)
    used = 0

    for i, (l, b) in enumerate(centers):
        core, rim = build_core_rim_masks(nside, l, b, theta_R_deg, core_frac, rim_in_frac, rim_out_frac)
        try:
            dT, *_ = deltaT_from_masks(cmb_uK, keep, core, rim, min_pix=min_pix)
            vals[i] = dT
            used += 1
        except RuntimeError:
            # In the rare case the annulus falls into a masked region heavily,
            # mark as NaN and exclude later.
            vals[i] = np.nan

    vals = vals[np.isfinite(vals)]
    if len(vals) < max(200, int(0.5 * n_rand)):
        raise RuntimeError(
            f"Null distribution lost too many samples after masking (kept {len(vals)} of {n_rand}). "
            "Relax mask_threshold, adjust θ_R, or lower bmin_deg."
        )

    return {
        "n_target": int(n_rand),
        "n_used": int(len(vals)),
        "bmin_deg": float(bmin_deg),
        "mean_uK": float(np.mean(vals)),
        "std_uK": float(np.std(vals, ddof=1)),
        "p05_uK": float(np.percentile(vals, 5)),
        "p16_uK": float(np.percentile(vals, 16)),
        "p50_uK": float(np.percentile(vals, 50)),
        "p84_uK": float(np.percentile(vals, 84)),
        "p95_uK": float(np.percentile(vals, 95)),
    }


# -----------------------------
# Main
# -----------------------------
def main():
    ap = argparse.ArgumentParser()

    # One or more maps (multi-map consistency)
    ap.add_argument(
        "--cmb_map",
        required=True,
        nargs="+",
        help="One or more Planck CMB HEALPix FITS files (e.g., SMICA, NILC, Commander).",
    )
    ap.add_argument("--cmb_field", type=int, default=0, help="FITS field index for temperature (default 0).")
    ap.add_argument("--map_in_uK", action="store_true", help="Set if the CMB map(s) are already in µK.")

    # Mask
    ap.add_argument("--mask", required=True, help="Path to a HEALPix mask FITS.")
    ap.add_argument("--mask_field", type=int, default=0, help="Mask field index (default 0).")
    ap.add_argument("--mask_threshold", type=float, default=0.8, help="Keep pixels with mask >= threshold.")

    # Target center (ICRS); script converts to Galactic for the measurement
    ap.add_argument("--ra_deg", type=float, default=222.5, help="Target center RA (deg, ICRS).")
    ap.add_argument("--dec_deg", type=float, default=46.0, help="Target center Dec (deg, ICRS).")

    # Aperture geometry
    ap.add_argument("--theta_R_deg", type=float, default=14.0, help="Void angular radius θ_R (deg).")
    ap.add_argument("--core_frac", type=float, default=0.6, help="Core radius fraction of θ_R.")
    ap.add_argument("--rim_in_frac", type=float, default=0.8, help="Rim inner radius fraction of θ_R.")
    ap.add_argument("--rim_out_frac", type=float, default=1.2, help="Rim outer radius fraction of θ_R.")
    ap.add_argument("--min_pix", type=int, default=50, help="Minimum unmasked pixels required per region.")

    # Bootstrap + null settings
    ap.add_argument("--bootstrap", type=int, default=2000, help="Bootstrap draws for uncertainty estimate.")
    ap.add_argument("--null_rand", type=int, default=2000, help="Random centers for null distribution.")
    ap.add_argument("--bmin_deg", type=float, default=50.0, help="Latitude cut for null centers (|b| >= bmin).")
    ap.add_argument("--seed", type=int, default=0, help="Random seed for bootstrap and null sampling.")

    # Output
    ap.add_argument("--out_json", default="", help="If set, write JSON output to this path.")

    args = ap.parse_args()

    keep = load_keep_mask(args.mask, field=args.mask_field, threshold=args.mask_threshold)
    l_deg, b_deg = radec_to_galactic(args.ra_deg, args.dec_deg)

    results = []

    for path in args.cmb_map:
        cmb = load_healpix_map(path, field=args.cmb_field)
        cmb_uK = to_uK(cmb, map_in_uK=args.map_in_uK)

        nside_map = hp.get_nside(cmb_uK)
        nside_mask = hp.get_nside(keep.astype(np.float64))
        if nside_map != nside_mask:
            raise ValueError(f"NSIDE mismatch: map={nside_map} mask={nside_mask} for {path}")

        core, rim = build_core_rim_masks(
            nside_map,
            l_deg,
            b_deg,
            args.theta_R_deg,
            args.core_frac,
            args.rim_in_frac,
            args.rim_out_frac,
        )

        dT, Tcore, Trim, ncore, nrim = deltaT_from_masks(
            cmb_uK, keep, core, rim, min_pix=args.min_pix
        )

        boot = bootstrap_deltaT(
            cmb_uK, keep, core, rim,
            n_boot=args.bootstrap,
            seed=args.seed,
            min_pix=args.min_pix,
        )

        null = null_distribution(
            cmb_uK, keep,
            theta_R_deg=args.theta_R_deg,
            core_frac=args.core_frac,
            rim_in_frac=args.rim_in_frac,
            rim_out_frac=args.rim_out_frac,
            n_rand=args.null_rand,
            bmin_deg=args.bmin_deg,
            seed=args.seed,
            min_pix=args.min_pix,
        )

        # z-score vs null
        z = (dT - null["mean_uK"]) / (null["std_uK"] if null["std_uK"] > 0 else np.nan)

        results.append({
            "map": path,
            "center_icrs": {"ra_deg": args.ra_deg, "dec_deg": args.dec_deg},
            "center_gal": {"l_deg": l_deg, "b_deg": b_deg},
            "aperture": {
                "theta_R_deg": args.theta_R_deg,
                "core_frac": args.core_frac,
                "rim_in_frac": args.rim_in_frac,
                "rim_out_frac": args.rim_out_frac,
                "min_pix": args.min_pix,
            },
            "mask": {
                "path": args.mask,
                "threshold": args.mask_threshold,
            },
            "measurement": {
                "DeltaT_uK": dT,
                "Tcore_uK": Tcore,
                "Trim_uK": Trim,
                "n_core_pix": ncore,
                "n_rim_pix": nrim,
            },
            "bootstrap": boot,
            "null_random_centers": null,
            "z_vs_null": float(z),
        })

    payload = {
        "script": "measurements/bootes_aperture_photometry_plus.py",
        "inputs": {
            "cmb_map": args.cmb_map,
            "cmb_field": args.cmb_field,
            "map_in_uK": bool(args.map_in_uK),
            "mask": args.mask,
            "mask_field": args.mask_field,
            "mask_threshold": args.mask_threshold,
            "ra_deg": args.ra_deg,
            "dec_deg": args.dec_deg,
            "theta_R_deg": args.theta_R_deg,
            "core_frac": args.core_frac,
            "rim_in_frac": args.rim_in_frac,
            "rim_out_frac": args.rim_out_frac,
            "min_pix": args.min_pix,
            "bootstrap": args.bootstrap,
            "null_rand": args.null_rand,
            "bmin_deg": args.bmin_deg,
            "seed": args.seed,
        },
        "notes": {
            "statistic": "DeltaT_uK = mean(core) - mean(rim)",
            "scope": (
                "Single-void measurement harness with uncertainty and a matched-latitude null. "
                "Not a stacking pipeline; interpret z_vs_null accordingly."
            ),
        },
        "results": results,
    }

    txt = json.dumps(payload, indent=2)
    print(txt)

    if args.out_json:
        with open(args.out_json, "w", encoding="utf-8") as f:
            f.write(txt)


if __name__ == "__main__":
    main()
